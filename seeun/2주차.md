- MVC (Model-View-Controller) 란
    
![image](https://user-images.githubusercontent.com/78543382/230727096-1b96402c-646a-4afe-a79a-a7186b08b63f.jpeg)
  - Model-View-Controller로 역할을 나누어 개발하는 방법론이다. 이렇게 역할을 나누면 비즈니스 처리 로직과 사용자 인터페이스 요소들을 분리시켜 서로 영향 없이 개발할 수 있다.
      - MVC는 소프트웨어가 서비스하는 방식에 대한 패턴을 지칭한다.
    
      - MVC는 어떤 프레임워크나 라이브러리를 지칭하는 것이 아닌 서비스 하는 방식에 대한 하나의 디자인 패턴이다.
- MVC 디자인 패턴 특징
    - 소프트웨어가 서비스하기 위해서는 여러 과정과 처리가 필요한데, 그러한 처리들을 각 기능 단위 별로 나눠서 처리한다. 이를 통해 프로그래밍을 할 때 역할을 하는 정돈된 코드를 작성할 수 있고, 코드 가독성을 높인다.
- Model
    - 데이터와 관련된 책임을 담당하는 레이어이다. 이때 데이터는 DB, 초기화 된 상수나 값, 변수 등을 뜻 한다.
    - 내부 비즈니스 로직을 처리한다.
    - 주로 상태 변화를 처리한다. 최근에는 Entity, VO, Aggregate로 나뉘어 관리한다 (DDD)
        - VO → 도메인에서 한 개 또는 그 이상의 속성들을 묶어 특정 값을 나타내는 객체를 의미한다. 도메인 객체의 일종이고 보통 기본 키로 식별 값을 가지는 Entity와 구별해서 사용한다.
        - Aggregate → 서로 관련이 있는 도메인 모델들의 집합이다. 많은 수의 도메인 모델 간의 복잡한 관계를 파악하기란 어려운 일이므로 서로 관련이 있는 도메인 모델들 끼리 묶어 각 도메인 모델의 상세 구현보다는 더 큰 그림으로 도메인 모델간의 관계를 파악하는것이 좋다. 이때 더 큰 그림이 Aggregate이다. 대부분의 경우 하나의 Aggregate는 하나의 엔티티와 여러개의 밸류로 구성된다.
    - Entity (영속성에서 테이블에 매칭되는 클래스)가 주로 대상이다.
    - 데이터와 행동을 가지는 객체이다.
    - 비즈니스 로직을 처리한 후 모델의 변경 사항을 컨트롤러에게 전달한다.
    - 모델이 뷰와 직접 소통하는 일은 없다.
- View
    - 사용자에게 보일 사용자 인터페이스를 담당하는 레이어이다.
    - 모델이 처리한 데이터를 받아 합산하고 클라이언트의 브라우저로 렌더링 되는 페이지이다.
    - 데이터, 로직은 없어야 한다.
    - 모델이나 데이터베이스와는 소통하지 않고 컨트롤러와만 소통한다.
    - 컨트롤러에게 액션이나 데이터를 전달만 하고 전달 받기만 한다.
    - 모델에게 전달받은 데이터는 별도로 저장하지 않아야 한다.
    - 동적으로 처리되어야 할 데이터를 시각화해준다.
- Controller
    - Model과 View를 연결해주는 레이어이다.
    - 클라이언트의 요청을 받으면 해당 요청에 대한 실제 업무를 수행하는 Model을 호출한다. 클라이언트가 보낸 데이터가 있다면, 모델을 호출할 때 전달하기 쉽게 적절히 가공한다. Model이 업무 수행을 완료하면 그 결과를 가지고 화면을 만들도록 View에 전달한다. 즉 Controller는 Model과 View를 결정하여 전달하는 일종의 조정자 역할이다.
    - Controller는 다른 컴포넌트들에 대해 알고 있고, 자기 자신 외에 Model과 View가 무엇을 수행하는지 알고 있다.
- MVC 패턴의 장점
    - 동시다발적으로 개발할 수 있다. 즉 백엔드와 프론트엔드가 독립적으로 개발할 수 있다.
    - 책임 영역이 구분되기 때문에 높은 응집도를 가지게 된다. 뷰와 모델이 다른 레이어에서 독립되 관리 가능한 의존도로 관리할 수 있다.

### Bean

---

- 애플리케이션의 핵심을 이루는 객체이며, 스프링 IoC 컨테이너를 통해 인스턴스화, 관리, 생성된다.
- POJO(Plain Old Java Object) 기반 객체이다.
- 스프링은 기본적으로 모든 bean을 singleton으로 생성하여 관리한다. 싱글톤 패턴처럼 특정 타입의 bean을 딱 하나만 만들고 모두 공유해서 사용하기 위함이다.
    - 구체적으로는 애플리케이션 구동 시 JVM 안에서 스프링이 bean 마다 하나의 객체를 생성하는 것을 의미한다.
    - 그렇기에 우리는 스프링을 통해 bean을 제공받으면 언제나 주입받은 bean은 동일한 객체라는 가정하에 개발을 한다.
    - 여러개의 bean이 필요하거나, 어떤 한 시점에서만 사용해야 하는 경우도 생기는데, 이는 SCOPE를 설정해줘야 한다.

### Singleton

---

- 애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고 그 메모리에 인스턴스를 만들어 사용하는 다자인 패턴이다.
- 하나만 생성하므로, 생성자가 여러 차례 호출되어도 실제로 생성되는 객체는 하나이다. 최초 생성 이후에 호출된 생성자는 최초에 생성자가 생성한 객체를 리턴한다.
- 인스턴스가 1개만 생성되기에 하나의 인스턴스를 메모리에 등록해서 여러 스레드가 동시에 해당 인스턴스를 공유하여 사용할 수 있게 할 수 있다.
    - 스레드: 스레드는 프로세스 내에서 실제로 작업을 수행하는 주체를 말한다. 스레드는 순서와 상관없이 실행된다.
- 주의해야 할 점은 동시성 문제를 고려해서 설계해야 한다는 것이다.
- 싱글톤 패턴의 장점
    - 고정된 메모리 영역을 얻으며 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있다.
    - 싱글톤으로 만들어진 클래스의 인스턴스는 전역으로 사용되기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.
    - 인스턴스가 절대적으로 한 개만 존재하는 것을 보증하고 싶을 경우 사용한다.
    - 두 번째 이용시 부터는 객체 로딩 시간이 줄어 성능이 좋아지는 장점이 있다.
- 싱글톤 패턴의 단점
    - 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 겨에 다른 클래스의 인스턴스들 간에 결합도가 높아져 계방-폐쇄 원칙을 위배하게 된다. 이는 객체 지향 설계 원칙에 어긋나기 때문에 수정이 어려워지고, 유지보수의 비용이 높아질 수 있다.