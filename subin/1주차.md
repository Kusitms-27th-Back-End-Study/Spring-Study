1주차 – WEB에 대한 전반적 이해 & 스프링 프레임워크 사용 이유
--------------------------------------------------------------

### WEB에 대한 전반적 이해 (REST API, HTTP/HTTP 2.0/HTTP 3.0/HTTPS)    
#### API(Application Programming Interface): 애플리케이션이 어떤 프로그램이 제공하는 기능을 사용할 수 있게 만든 매개체     

>서버는 프로그램에게 자신이 제공하고자 하는 데이터나 기능을 제어할 수 있는 API로 제작 -> 접근 제한이 있는 프로그래머나 프로그램이 API를 통해 서버에게 제공하는 데이터를 요청하여 사용
><pre><code>Ex) 날씨 정보 앱
>  기상청(서버)이 제공하는 API에 원하는 날씨 정보를 요청 -> 데이터를 받음 -> UI 형태로 사용자에게 정보 제공   
>
>  즉, API는 기상청이 DB에 날씨 정보를 보관하고 프로그램이 DB 서버에 날씨 데이터를 조회, 조작할 수 있도록 미리 개발된 것
>  </pre></code>
<br/>

#### (1)	REST API
REST(Representational State Transfer)란 네트워크 아키텍처 스타일.
REST는 HTTP를 잘 활용하기 위한 원칙이라 할 수 있고 REST API는 이 원칙을 준수하여 만든 API.

>HTTP를 잘 활용하기 위한 원칙은?
>* URI를 자원(리소스)를 표현
>* 자원에 대한 행위는 HTTP METHOD(GET, POST, PUT, DELETE)로 표현
>
><pre><code>ex 1) GET /members/delete/1 (delete와 같이 행위에 대한 표현 X, URI에는 자원만 표현)  
>      ㄴ> DELETE /members/1
>ex 2) GET /members/insert/2 (GET 메소드는 리소스 생성에 맞지 X)
>      ㄴ> POST /members/2
></pre></code>


##### 정리: REST API는 HTTP 프로토콜을 따르면서 아래의 4가지의 가이드 원칙을 따라야 됨
-	자원의 식별
-	자기 서술적 메시지
-	메시지를 통한 리소스 조작
-	애플리케이션의 상태에 대한 엔진으로서 하이퍼 미디어

###### 구현하기 어려운 부분은 4번째 부분. HTML처럼 하이퍼링크가 추가되어 다음에 어떤 API를 호출해야 하는지를 해당 링크를 통해 받을 수 있어야 됨.

##### RESTful API: 위 네 개의 제약 조건을 완벽하게 지키면서 개발하는 것
<br/>

#### (2)	HTTP API
HTTP를 사용하여 프로그램끼리 소통하는 API. 우리가 아는 OPEN API, facebook API, kakao API 등 대부분의 API는 HTTP라는 통신 규칙으로 소통하는 API.

><pre><code>ex ) Google 캘린더에서 Zoom 회의를 설정할 때마다 HTTP API를 사용
>이때 API는 Zoom이 Google 서버와 직접 통신하여 회의 초대장을 필드에 복사하여 붙여넣는 대신 Zoom 회의를 이벤트에 포함</pre></code>

##### 1. HTTP 1.1
* 1999년 등장하여 HTTP 2.0이 등장하기 전까지 15년 동안 지속.
* 연결당 하나의 요청과 응답을 처리하기 때문에 동시 전송 문제와 다수의 리소스를 처리하기에 속도와 성능 이슈가 존재
* HTTP Pipelining의 도입

>##### HTTP Pipelining
>TCP 안에 두 개 이상의 HTTP 요청을 담아 Network Latency을 줄이는 방식
>구현하기 힘들 뿐만 아니라 HOL Blocking 발생

>##### HOL Blocking
>Head of Line의 줄임말로서 앞선 요청에 의해 뒤에 요청이 지연되는 것을 의미. HTTP Pipelining 을 통해 한 번에 여러 요청을 하는 경우, 첫 번째 응답이 지연되면 다음 응답도 지연 발생

>##### 무거운 Header
>헤더의 동일한 정보를 중복 전송하고 cookie 정보도 매 요청마다 헤더에 포함되어 전송. 불필요한 데이터를 주고 받는데 네트워크 자원이 소비되는 문제가 발생

<br/>

##### 2. HTTP 2.0
* 기존 HTTP 1.1을 개선하는 방향에서, 성능 쪽에 초점을 맞춘 프로토콜

>##### Multiplexed Streams
> 하나의 Connection으로 동시에 여러 개의 메세지를 주고 받음. 응답은 요청 순서에 상관없이 Stream으로 받기 때문에 HOL Blocking 발생 X


>##### Stream Prioritization
> 응답에 대한 우선순위를 정해 우선순위가 높을수록 응답을 빨리 함. 응답이 느린 파일을 기다리느라 클라이언트가 렌더링하지 못하는 상황 방지

>##### Server Push
> 서버가 클라이언트의 요청없이 응답을 보내는 방법. 클라이언트의 요청을 최소화하고 서버가 리소스를 자동으로 전송.

>##### Header Compression
> 클라이언트와 서버는 각각 Header Table을 관리하고 이전 요청과 동일한 필드는 table의 index만 보내고, 변경 값은 Huffman Encoding 후 전송하여 Header 크기를 경령화

<br/>

##### HTTP 1.1 VS HTTP 2.0

<img src="https://www.egon.expert/storage/app/uploads/public/5b4/0ec/aa6/5b40ecaa6d87b013097203.gif" width="450px" height="450px"></img>

HTTP/1.1과 HTTP/2.0의 차이를 잘 보여주는 사진이다.

<br/>


##### 3. HTTP 3.0
* 가장 큰 특징은 TCP가 아닌 UDP를 사용하는 것
* HTTP 3.0에서 사용하는 QUIC는 Quick UDP Internet Connection의 약자로 UDP를 사용하는 프로토콜

<pre><code>UDP는 데이터그램 방식을 사용하는 프로토콜이기에 각각의 패킷 간 순서가 존재하지 않는 독립적인 패킷.
TCP에 비해 헤더가 많이 비어있기에, 개발자가 구현을 어떻게 하느냐에 따라서 신뢰성 확보 가능.
</pre></code>

>##### 패킷 손실 감지에 걸리는 시간 단축
> QUIC는 헤더에 별도의 패킷 번호 공간을 부여해 패킷 손실 감지에 걸리는 시간을 단축

>##### 멀티플렉싱 지원
> 여러 개의 스트림을 사용하면 특정 스트림의 패킷이 손실되어도 해당 스트림에만 영향을 미치고 나머지 스트림은 정상 사용 가능

>##### 클라이언트의 IP가 바뀌어도 연결 유지
> connection ID를 사용해 서버와 연결을 생성. 이는 클라이언트 IP와는 전혀 무관하기 때문에 클라이언트 IP가 변경되더라도 기존의 연결과 유지 가능

<br/>

##### 4. HTTPS
* HTTP에 데이터 암호화가 추가된 프로토콜
* HTTPS는 HTTP와 다르게 443번 포트를 사용
* 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 암호화를 지원

###### HTTPS의 보안 방식
<pre><code> HTTPS는 SSL SSL(Secure Sockets Layer) 위에 HTTP를 얹어서 보안이 보장된 통신을 하는 프로토콜(=SSL 암호화 통신)
SSL 암호화 통신은 공개키 암호화 방식이라는 알고리즘을 통해 구현</pre></code>
 
 
### 스프링 프레임워크 사용 이유
##### 소프트웨어 프레임워크(software framework): 소프트웨어의 설계와 구현을 재사용이 가능하도록 일련의 협업화된 형태로 클래스 제공하는 것.

###### 프레임워크 사용 장점
* 설정보다 개발 업무에 집중 가능
* 오랜 기간동안 확립된 디자인 패턴을 기반으로 설정
* 표준을 준수
* 비용 절감 효과 (생산량 증가)

###### 프레임워크 사용 단점
* 특정 방식대로 코드를 짜야 함
* 언어나 라이브러리의 특정 버전만을 사용

###### 스프링 프레임 워크를 사용해야 되는 이유

>##### 편리함
> 기본적인 설정 등을 제공하기에 옵션을 설정에 시간 소비할 필요가 없으며 편리하고 로직 개발에 집중 가능
 
>##### 모듈성 
> 모듈화가 잘 되어 있기 때문에 Spring에서 제공하는 모듈 중 필요한 프로젝트를 선택적으로 사용 가능. 

>##### 가벼움 
> POJO(Plain Old Java Object)를 지원. 즉, 별도의 API를 사용하지 않고 일반 자바 코드만으로 구성 가능하기 때문에 기본적으로 매우 가벼움.

>##### 테스팅
> TDD(Test Driven Development)를 지원. 대체로 POJO로 구성되어 있기 때문에 단위 테스트가 용이하고, 복잡하지 않은 MVC 등의 시나리오에 대해 모의 객체를 제공.

>##### 커뮤니티 
>Pivotal Software의 오픈 소스로써 공식적인 레퍼런스, 튜토리얼을 제공. 또한, 사용자가 많은만큼 관련 질의응답도 수월.

 
